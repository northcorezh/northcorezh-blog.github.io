<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.northcorezh.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基础命名在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。 关键字Go语言的关键字有25个 12345break      default       func     interface   selectcase       defer         go       map         structchan       el">
<meta property="og:type" content="article">
<meta property="og:title" content="Go学习笔记之基础知识(一)">
<meta property="og:url" content="https://blog.northcorezh.com/2021/11/21/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/index.html">
<meta property="og:site_name" content="帽儿山的枪手博客">
<meta property="og:description" content="基础命名在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。 关键字Go语言的关键字有25个 12345break      default       func     interface   selectcase       defer         go       map         structchan       el">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-21T12:27:00.000Z">
<meta property="article:modified_time" content="2021-12-05T11:58:23.002Z">
<meta property="article:author" content="ChangHao">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.northcorezh.com/2021/11/21/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Go学习笔记之基础知识(一) | 帽儿山的枪手博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">帽儿山的枪手博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.northcorezh.com/2021/11/21/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ChangHao">
      <meta itemprop="description" content="技术分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="帽儿山的枪手博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go学习笔记之基础知识(一)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-21 20:27:00" itemprop="dateCreated datePublished" datetime="2021-11-21T20:27:00+08:00">2021-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-05 19:58:23" itemprop="dateModified" datetime="2021-12-05T19:58:23+08:00">2021-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Go学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>在习惯上，Go语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>Go语言的关键字有25个</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>      <span class="keyword">default</span>       <span class="function"><span class="keyword">func</span>     <span class="title">interface</span>   <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>       <span class="keyword">defer</span>         <span class="keyword">go</span>       <span class="keyword">map</span>         <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>       <span class="keyword">else</span>          <span class="keyword">goto</span>     <span class="keyword">package</span>     <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>      <span class="keyword">fallthrough</span>   <span class="keyword">if</span>       <span class="keyword">range</span>       <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>   <span class="keyword">for</span>           <span class="keyword">import</span>   <span class="keyword">return</span>      <span class="keyword">var</span></span><br></pre></td></tr></table></figure>



<h4 id="预定义的名称"><a href="#预定义的名称" class="headerlink" title="预定义的名称"></a>预定义的名称</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内建常量 </span></span><br><span class="line"><span class="literal">true</span> <span class="literal">false</span> <span class="literal">iota</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内建类型 </span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">int8</span> <span class="keyword">int16</span> <span class="keyword">int32</span> <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span> <span class="keyword">complex128</span> <span class="keyword">complex64</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">byte</span> <span class="keyword">rune</span> <span class="keyword">string</span> error</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内建函数</span></span><br><span class="line"><span class="built_in">make</span> <span class="built_in">len</span> <span class="built_in">cap</span> <span class="built_in">new</span> <span class="built_in">append</span> <span class="built_in">copy</span> <span class="built_in">close</span> <span class="built_in">delete</span></span><br><span class="line"><span class="built_in">complex</span> <span class="built_in">real</span> <span class="built_in">imag</span></span><br><span class="line"><span class="built_in">panic</span> <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>

<p>这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。</p>
<span id="more"></span>



<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。</p>
<p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量(anonymous variable)</code> 匿名变量用一个下划线_ 表示</p>
<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。</p>
<h5 id="基础声明"><a href="#基础声明" class="headerlink" title="基础声明"></a>基础声明</h5><p>var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。</p>
<p>变量声明的一般语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure>



<p>数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil</p>
<p>数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p>
<p>零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Println(s) <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>



<p>也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j, k <span class="keyword">int</span>                 <span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">&quot;four&quot;</span> <span class="comment">// bool, float64, string</span></span><br></pre></td></tr></table></figure>



<p>一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f, err = os.Open(name) <span class="comment">// os.Open returns a file and an error</span></span><br></pre></td></tr></table></figure>



<p>Go 语言中变量的声明必须使用空格隔开</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br></pre></td></tr></table></figure>



<h5 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a>简短变量声明</h5><p>在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。</p>
<p>和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i, j := <span class="number">0</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作。</p>
<p>和普通var形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始化变量，像下面的os.Open函数调用将返回两个值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...use f...</span></span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure>



<h5 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a><strong>批量声明</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a <span class="keyword">string</span></span><br><span class="line">  b <span class="keyword">int</span></span><br><span class="line">  c <span class="keyword">bool</span></span><br><span class="line">  d <span class="keyword">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h5 id="指针变量声明"><a href="#指针变量声明" class="headerlink" title="指针变量声明"></a>指针变量声明</h5><p>如果用“var x int”声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>，指针被称之为“指向int类型的指针”。</p>
<p>如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时<code>*p</code>表达式对应p指针指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为int类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x					<span class="comment">// p, of type *int, points to x</span></span><br><span class="line">fmt.Println(*p)	<span class="comment">// &quot;1&quot;</span></span><br><span class="line">*p = <span class="number">2</span></span><br><span class="line">fmt.Println(x)	<span class="comment">// &quot;2&quot;</span></span><br></pre></td></tr></table></figure>



<p>变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受<code>&amp;</code>取地址操作。</p>
<p><strong>任何类型的指针的零值都是nil</strong>。如果p指向某个有效变量，那么<code>p != nil</code>测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line">fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span class="literal">nil</span>) <span class="comment">// &quot;true false false&quot;</span></span><br></pre></td></tr></table></figure>



<p>在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = f()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">  v := <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> &amp;v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用f函数都将返回不同的结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(f() == f())	<span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>



<p>因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(p *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  *p++		<span class="comment">// 非常重要: 只是增加p指向的变量值, 并不改变p指针</span></span><br><span class="line">  <span class="keyword">return</span> *p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v := <span class="number">1</span></span><br><span class="line">incr(&amp;v)							<span class="comment">// v is show 2</span></span><br><span class="line">fmt.Println(incr(&amp;v))	<span class="comment">// &quot;3&quot; (and v is 3)</span></span><br></pre></td></tr></table></figure>



<p>每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。例如，<code>*p</code>就是变量v的别名。指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（注：这是Go语言的垃圾回收器所做的工作）</p>
<p>不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。</p>
<h5 id="new函数变量声明"><a href="#new函数变量声明" class="headerlink" title="new函数变量声明"></a>new函数变量声明</h5><p>另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)		<span class="comment">// p, *int 类型, 指向匿名的int 变量</span></span><br><span class="line">fmt.Println(*p)	<span class="comment">// &quot;0&quot;</span></span><br><span class="line">*p = <span class="number">2</span>					<span class="comment">// 设置 int 匿名变量的值为2</span></span><br><span class="line">fmt.Println(*p)	<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，<strong>new函数类似是一种语法糖</strong>，而不是一个新的基础概念。</p>
<p>每次调用new函数都是返回一个新的变量的地址, 因此下面两个地址不同的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">q := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(p == q)		<span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。</p>
<h5 id="变量的声明周期"><a href="#变量的声明周期" class="headerlink" title="变量的声明周期"></a>变量的声明周期</h5><p>变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。</p>
<p>而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。</p>
<p>函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</p>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>                       <span class="comment">// 命名变量的赋值</span></span><br><span class="line">*p = <span class="literal">true</span>                   <span class="comment">// 通过指针间接赋值</span></span><br><span class="line">person.name = <span class="string">&quot;bob&quot;</span>         <span class="comment">// 结构体字段赋值</span></span><br><span class="line">count[x] = count[x] * scale <span class="comment">// 数组、slice或map的元素赋值</span></span><br></pre></td></tr></table></figure>

<p>特定的二元算术运算符和赋值语句的复合操作有一个简洁形式，例如上面最后的语句可以重写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count[x] *= scale</span><br></pre></td></tr></table></figure>

<p>一次初始化多个变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name, sex = <span class="string">&quot;pprof&quot;</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h5 id="元组赋值"><a href="#元组赋值" class="headerlink" title="元组赋值"></a>元组赋值</h5><p>元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。</p>
<p>这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助，例如我们可以这样交换两个变量的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x</span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br></pre></td></tr></table></figure>

<p>和变量声明一样，我们可以用 <strong>下划线</strong> 空白标识符 <code>_</code> 来丢弃不需要的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, err = io.Copy(dst, src) <span class="comment">// 丢弃字节数</span></span><br><span class="line">_, ok = x.(T)              <span class="comment">// 只检测类型，忽略具体值</span></span><br></pre></td></tr></table></figure>



<h5 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h5><p>赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medals := []<span class="keyword">string</span>&#123;<span class="string">&quot;gold&quot;</span>, <span class="string">&quot;silver&quot;</span>, <span class="string">&quot;bronze&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>隐式地对slice的每个元素进行赋值操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">medals[<span class="number">0</span>] = <span class="string">&quot;gold&quot;</span></span><br><span class="line">medals[<span class="number">1</span>] = <span class="string">&quot;silver&quot;</span></span><br><span class="line">medals[<span class="number">2</span>] = <span class="string">&quot;bronze&quot;</span></span><br></pre></td></tr></table></figure>

<p>map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。</p>
<p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。</p>
<p>类型必须完全匹配，<strong>nil可以赋值给任何指针或引用类型的变量</strong>。常量则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。</p>
<p>对于两个值是否可以用<code>==</code>或<code>!=</code>进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。</p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。</p>
<p>新命名的类型，用来分割不同概念的类型，这样即使它们底层类型相同也不是兼容的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名字 底层类型</span><br></pre></td></tr></table></figure>

<p>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。</p>
<p>说明类型声明, 将不同温度单位分别定义为不同的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	AbsoluteZeroC Celsius = <span class="number">-273.15</span>		<span class="comment">// 绝对零度</span></span><br><span class="line">    FreezingC	Celsius = <span class="number">0</span>				<span class="comment">// 结冰点温度</span></span><br><span class="line">    BoilingC	Celsius = <span class="number">100</span>			<span class="comment">// 沸水温度</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span> <span class="title">Fahrenheit</span></span> &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span> <span class="title">Celsius</span></span> &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"><span class="keyword">int</span>(<span class="number">32</span> or <span class="number">64</span>), <span class="keyword">int8</span>, <span class="keyword">int16</span>, <span class="keyword">int32</span>, <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span>(<span class="number">32</span> or <span class="number">64</span>), <span class="keyword">uint8</span>(<span class="keyword">byte</span>), <span class="keyword">uint16</span>, <span class="keyword">uint32</span>, <span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">float32</span>, <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">complex64</span>, <span class="keyword">complex128</span></span><br><span class="line">array    -- 固定长度的数组</span><br></pre></td></tr></table></figure>



<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice   -- 序列数组(最常用)</span><br><span class="line"><span class="keyword">map</span>     -- 映射</span><br><span class="line"><span class="keyword">chan</span>    -- 管道</span><br></pre></td></tr></table></figure>



<h4 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a>包和文件</h4><p>Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径</p>
<p>包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。<strong>在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的。</strong></p>
<p>包代码存储在两个源文件中，用来演示如何在一个源文件声明然后在其他的源文件访问；虽然在现实中，这样小的包一般只需要一个文件。</p>
<p>gopl.io/ch2/tempconv</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package tempconv performs Celsius and Fahrenheit conversions.</span></span><br><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Celsius <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Fahrenheit <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    AbsoluteZeroC Celsius = <span class="number">-273.15</span></span><br><span class="line">    FreezingC     Celsius = <span class="number">0</span></span><br><span class="line">    BoilingC      Celsius = <span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Celsius)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>    &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%g°C&quot;</span>, c) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Fahrenheit)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%g°F&quot;</span>, f) &#125;</span><br></pre></td></tr></table></figure>

<p>转换函数则放在另一个conv.go源文件中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tempconv</span><br><span class="line"></span><br><span class="line"><span class="comment">// CToF converts a Celsius temperature to Fahrenheit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CToF</span><span class="params">(c Celsius)</span> <span class="title">Fahrenheit</span></span> &#123; <span class="keyword">return</span> Fahrenheit(c*<span class="number">9</span>/<span class="number">5</span> + <span class="number">32</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FToC converts a Fahrenheit temperature to Celsius.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FToC</span><span class="params">(f Fahrenheit)</span> <span class="title">Celsius</span></span> &#123; <span class="keyword">return</span> Celsius((f - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>每个源文件都是以包的声明语句开始，用来指明包的名字。当包被导入的时候，包内的成员将 <strong>通过类似tempconv.CToF的形式访问</strong>。</p>
<p>而包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。</p>
<p>因为<strong>包级别的常量名都是以大写字母开头</strong>，它们可以像tempconv.AbsoluteZeroC这样被外部代码访问：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;Brrrr! %v\n&quot;</span>, tempconv.AbsoluteZeroC) <span class="comment">// &quot;Brrrr! -273.15°C&quot;</span></span><br></pre></td></tr></table></figure>

<p>在每个源文件的包声明前紧跟着的注释是包注释。<strong>通常，包注释的第一句应该先是包的功能概要说明。</strong> 一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。</p>
<h5 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h5><p><strong>在Go语言程序中，每个包都有一个全局唯一的导入路径。</strong></p>
<p>除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。</p>
<p>按照惯例，<strong>一个包的名字和包的导入路径的最后一个字段相同</strong>，例如gopl.io/ch2/tempconv包的名字一般是tempconv。</p>
<p>要使用gopl.io/ch2/tempconv包，需要先导入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cf converts its numeric argument to Celsius and Fahrenheit.package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;strconv&quot;    &quot;gopl.io/ch2/tempconv&quot;)func main() &#123;    for _, arg := range os.Args[1:] &#123;        t, err := strconv.ParseFloat(arg, 64)        if err != nil &#123;            fmt.Fprintf(os.Stderr, &quot;cf: %v\n&quot;, err)            os.Exit(1)        &#125;        f := tempconv.Fahrenheit(t)        c := tempconv.Celsius(t)        fmt.Printf(&quot;%s = %s, %s = %s\n&quot;,            f, tempconv.FToC(f), c, tempconv.CToF(c))    &#125;&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="初始化包"><a href="#初始化包" class="headerlink" title="初始化包"></a>初始化包</h5><p>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c		<span class="comment">// a 第三个初始化, 为3var b = f()			// b 第二个初始化, 为2, 通过调用 f (依赖c)var c = 1				// c 第一个初始化, 为1func f() int &#123; return c + 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，<strong>Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</strong></p>
<h5 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h5><blockquote>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34211611">五分钟理解golang的init函数</a></p>
</blockquote>
<p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，<strong>我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。</p>
<p><strong>init函数先于main函数执行</strong></p>
<p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。</p>
<p>有下面的几个特征：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> init函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等<span class="number">2</span> 每个包可以拥有多个init函数<span class="number">3</span> 包的每个源文件也可以拥有多个init函数<span class="number">4</span> 同一个包中多个init函数的执行顺序<span class="keyword">go</span>语言没有明确的定义(说明)<span class="number">5</span> 不同包的init函数按照包导入的依赖关系决定该初始化函数的执行顺序<span class="number">6</span> init函数不能被其他函数调用，而是在main函数执行之前，自动被调用</span><br></pre></td></tr></table></figure>



<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>下面的例子同样有三个不同的x变量，每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化词法域，一个在for循环体词法域；只有两个块是显式创建的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  x := <span class="string">&quot;hello&quot;</span>  <span class="keyword">for</span> _, x := <span class="keyword">range</span> x &#123;    x := x + <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>    fmt.Printf(<span class="string">&quot;%c&quot;</span>, x)  &#125;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>Go语言的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。</p>
<p>Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。</p>
<p>这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint；其中int是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设；因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。</p>
<p>Unicode字符 <strong>rune类型</strong> 是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样 <strong>byte也是uint8类型</strong> 的等价类型，<strong>byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。</strong></p>
<p><strong>还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。</strong>uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。</p>
<p>不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。</p>
<blockquote>
<p>go语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小是4字节；如果是64位操作系统，int类型的大小就是8个字节</p>
</blockquote>
<h5 id="int"><a href="#int" class="headerlink" title="int"></a>int</h5><p>int 类型大小为 8 字节</p>
<h5 id="int8"><a href="#int8" class="headerlink" title="int8"></a>int8</h5><p>int8 类型大小为 1 字节<br>无符号整数的所有bit位都用于表示非负数，值域是0到$2^n-1$。例如，int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255。</p>
<h5 id="int16"><a href="#int16" class="headerlink" title="int16"></a>int16</h5><p>int16 类型大小为2字节<br>有符号int16类型整数值域是从 -32768 ~ 32767，而无符号uint16类型整数值域是从 0 ~ 65535</p>
<h5 id="int32"><a href="#int32" class="headerlink" title="int32"></a>int32</h5><p>int32 类型大小为 4 字节<br>有符号int32类型整数值域是从 -2147483648 ~ 2147483647，而无符号uint32类型整数值域是从 0 ~ 4294967295</p>
<h5 id="int64"><a href="#int64" class="headerlink" title="int64"></a>int64</h5><p>int64 类型大小为 8 字节<br>有符号int64类型整数值域是从 -9223372036854775808 ~ 9223372036854775807，而无符号uint64类型整数值域是从 0 ~ 18446744073709551615</p>
<h5 id="int-int8-int16-int32-int64-取值范围"><a href="#int-int8-int16-int32-int64-取值范围" class="headerlink" title="int int8 int16 int32 int64 取值范围"></a>int int8 int16 int32 int64 取值范围</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math&quot;</span></span><br><span class="line">  <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;各int类型的大小: &quot;</span>)</span><br><span class="line">  <span class="keyword">var</span> i1 <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> i2 <span class="keyword">int8</span> = <span class="number">2</span></span><br><span class="line">  <span class="keyword">var</span> i3 <span class="keyword">int16</span> = <span class="number">3</span></span><br><span class="line">  <span class="keyword">var</span> i4 <span class="keyword">int32</span> = <span class="number">4</span></span><br><span class="line">  <span class="keyword">var</span> i5 <span class="keyword">int64</span> = <span class="number">5</span></span><br><span class="line">  <span class="keyword">var</span> i6 <span class="keyword">uint64</span> = <span class="number">6</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;int		: %v\n&quot;</span>, unsafe.Sizeof(i1))</span><br><span class="line">  fmt.Printf(<span class="string">&quot;int8	: %v\n&quot;</span>, unsafe.Sizeof(i2))</span><br><span class="line">  fmt.Printf(<span class="string">&quot;int16	: %v\n&quot;</span>, unsafe.Sizeof(i3))</span><br><span class="line">  fmt.Printf(<span class="string">&quot;int32	: %v\n&quot;</span>, unsafe.Sizeof(i4))</span><br><span class="line">  fmt.Printf(<span class="string">&quot;int64	: %v\n&quot;</span>, unsafe.Sizeof(i5))</span><br><span class="line">  fmt.Printf(<span class="string">&quot;uint64: %v\n&quot;</span>, unsafe.Sizeof(i6))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出各int类型的取值范围</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;int8:&quot;</span>, math.MinInt8, <span class="string">&quot;~&quot;</span>, math.MaxInt8)</span><br><span class="line">  fmt.Println(<span class="string">&quot;int16:&quot;</span>, math.MinInt16, <span class="string">&quot;~&quot;</span>, math.MaxInt16)</span><br><span class="line">  fmt.Println(<span class="string">&quot;int32:&quot;</span>, math.MinInt32, <span class="string">&quot;~&quot;</span>, math.MaxInt32)</span><br><span class="line">  fmt.Println(<span class="string">&quot;int64:&quot;</span>, math.MinInt64, <span class="string">&quot;~&quot;</span>, math.MaxInt64)</span><br><span class="line">  fmt.Println()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// n是自动推导类型</span></span><br><span class="line">  n := <span class="number">1234567890</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;n := 1234567890 的默认类型为: %T\n&quot;</span>, n)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;int类型的字节数为: %v\n\n&quot;</span>, unsafe.Sizeof(n))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化一个32位整型值</span></span><br><span class="line">  <span class="keyword">var</span> a <span class="keyword">int32</span> = <span class="number">987654321</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;var a int32 = 987654321&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出变量的十六进制形式和十进制</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;int32: 十六进制为0x%x, 十进制为%d\n&quot;</span>, a, a)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将a转换为int8类型, 发生数值截断</span></span><br><span class="line">  b := <span class="keyword">int8</span>(a)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;int8: 十六进制0x%x, 十进制为%d\n&quot;</span>, b, b)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将a转换为int16类型, 发生数值截断</span></span><br><span class="line">  c := <span class="keyword">int16</span>(a)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;int16: 十六进制为0x%x, 十进制%d\n&quot;</span>, c, c)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将a转换为int64类型</span></span><br><span class="line">  d := <span class="keyword">int64</span>(a)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;int64: 十六进制为0x%x, 十进制%d\n&quot;</span>, d, d)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="uintptr"><a href="#uintptr" class="headerlink" title="uintptr"></a>uintptr</h5><p>长度4或8字节， 以存储指针的uint32 或 uint64整数</p>
<p>Go语言中关于算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*      /      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^</span><br><span class="line">+      -      |      ^</span><br><span class="line">==     !=     &lt;      &lt;=       &gt;      &gt;=</span><br><span class="line">&amp;&amp;</span><br><span class="line">||</span><br></pre></td></tr></table></figure>



<p>一个算术运算的结果，不管是有符号或者是无符号的，如果需要更多的bit位才能正确表示的话，就说明计算结果是溢出了。超出的高位的bit位部分将被丢弃。如果原始的数值是有符号类型，而且最左边的bit位是1的话，那么最终结果可能是负的</p>
<p>int8的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u <span class="keyword">uint8</span> = <span class="number">255</span></span><br><span class="line">fmt.Println(u, u+<span class="number">1</span>, u*u)	<span class="comment">// &quot;255 0 1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int8</span> = <span class="number">127</span></span><br><span class="line">fmt.Println(i, i+<span class="number">1</span>, i*i)	<span class="comment">// &quot;127 -128 1&quot;</span></span><br></pre></td></tr></table></figure>



<p>两个相同的整数类型可以不同使用下面的二元比较运算符进行比较；比较表达式的结果是布尔类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==		等于</span><br><span class="line">!=		不等于</span><br><span class="line">&lt;			小于</span><br><span class="line">&lt;=		小于等于</span><br><span class="line">&gt;			大于</span><br><span class="line">&gt;=		大于等于</span><br></pre></td></tr></table></figure>



<p>Go 语言提供了以下bit位操作运算符，前4个操作运算符并不区分是有符号还是无符号</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;			位运算	AND</span><br><span class="line">|			位运算 OR</span><br><span class="line">^			位运算 XOR</span><br><span class="line">&amp;^		位清空 (AND NOT)</span><br><span class="line">&lt;&lt;		左移</span><br><span class="line">&gt;&gt;		右移</span><br></pre></td></tr></table></figure>

<p>位操作运算符<code>^</code>作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；也就是说，它返回一个每个bit位都取反的数。</p>
<p>在<code>x&lt;&lt;n</code>和<code>x&gt;&gt;n</code>移位运算中，决定了移位操作的bit数部分必须是无符号数；被操作的x可以是有符号数或无符号数。</p>
<p>尽管Go语言提供了无符号数的运算，但即使数值本身不可能出现负数，我们还是倾向于使用有符号的int类型，就像数组的长度那样，虽然使用uint无符号类型似乎是一个更合理的选择。</p>
<p>内置的len函数返回一个有符号的int， 我们可以像下面例子处理逆序循环</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">medals := []<span class="keyword">string</span>&#123;<span class="string">&quot;gold&quot;</span>, <span class="string">&quot;silver&quot;</span>, <span class="string">&quot;bronze&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(medals) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">  fmt.Println(medals[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于每种类型T，如果转换允许的话，类型转换操作T(x)将x转换为T类型。许多整数之间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="number">3.141</span>						<span class="comment">// a float64</span></span><br><span class="line">i := <span class="keyword">int</span>(f)</span><br><span class="line">fmt.Println(f, i)			<span class="comment">// &quot;3.141 3&quot;</span></span><br><span class="line">f = <span class="number">1.99</span></span><br><span class="line">fmt.Println(<span class="keyword">int</span>(f))		<span class="comment">// &quot;1&quot;</span></span><br></pre></td></tr></table></figure>



<p>浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="number">1e100</span>						<span class="comment">// a float64i := int(f)						// 结果依赖于具体实现</span></span><br></pre></td></tr></table></figure>



<p>任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。如今八进制数据通常用于POSIX操作系统上的文件访问权限标志，十六进制数字则更强调数字值的bit位模式</p>
<p>当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o := <span class="number">0666</span>fmt.Printf(<span class="string">&quot;%d %[1]o %#[1]o \n&quot;</span>, o)			<span class="comment">// &quot;438 666 0666&quot;x := int64(0xdeadbeef)fmt.Printf(&quot;%d %[1]x %#[1]x %#[1]X \n&quot;, x)// Output:// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</span></span><br></pre></td></tr></table></figure>



<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数类型的取值范围可以从很微小到很巨大。浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。</p>
<p>一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = <span class="number">16777216</span>			<span class="comment">// 1 &lt;&lt; 24fmt.Println(f == f+1)					// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>



<p>浮点数的字面值可以写成小数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e = <span class="number">2.71828</span></span><br></pre></td></tr></table></figure>



<p>小数点前面或后面的数字都可能被省略。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Avogadro = <span class="number">6.02214129e23</span>  <span class="comment">// 阿伏伽德罗常数const Planck   = 6.62606957e-34 // 普朗克常数</span></span><br></pre></td></tr></table></figure>



<p>Printf函数的<strong>%g参数打印浮点数</strong>，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">8</span>; x++ &#123;  fmt.Printf(<span class="string">&quot;x = %d e^x = %8.3f\n&quot;</span>, x, math.Exp(<span class="keyword">float64</span>(x)))&#125;</span><br></pre></td></tr></table></figure>



<h5 id="float32"><a href="#float32" class="headerlink" title="float32"></a>float32</h5><p>单精度类型，占据4个字节byte，32个二进制位bit</p>
<h5 id="float64"><a href="#float64" class="headerlink" title="float64"></a>float64</h5><p>双精度类型，占据8个字节byte，64个二进制位bit</p>
<p>双精度类型比单精度类型更能精确地表示一个小数，但是占用的内存空间也比较大。</p>
<h4 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h4><p>Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。存储这两个类型的值空间分别需要8个字节和16个字节。</p>
<p>实际上，complex64类型的值会由两个float32类型的值分别表示复数的实数部分和虚数部分。 complex128类型的值会由两个float64类型的值分别表示复数的实数部分和虚数部分。</p>
<p>复数类型的值一般由浮点数表示的实数部分、加号“+”、浮点数表示的虚数部分，以及小写字母“i”组成。比如， <code>3.7E+1 + 5.98E-2i</code> 。正因为复数类型的值由两个浮点数类型值组成，所以其表示法的规则自然需遵从浮点数类型的值表示法的相关规则。</p>
<p>内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">1</span>, <span class="number">2</span>)			<span class="comment">// 1+2ivar y complex128 = complex(3, 4)			// 3+4ifmt.Println(x*y)											// &quot;(-5+10i)&quot;fmt.Println(real(x*y))								// &quot;-5&quot;fmt.Println(imag(x*y))								// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>



<p>在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像1+2i或与之等价的写法2i+1。上面x和y的声明语句还可以简化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span> + <span class="number">2i</span>y := <span class="number">3</span> + <span class="number">4i</span></span><br></pre></td></tr></table></figure>



<p>复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的</p>
<p>math/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(cmplx.Sqrt(<span class="number">-1</span>))			<span class="comment">// &quot;(0+1i)&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>一个布尔类型的值只有两种：true和false。if和for语句的条件部分都是布尔类型的值，并且==和&lt;等比较操作也会产生布尔型的值。一元操作符<code>!</code>对应逻辑非操作，因此<code>!true</code>的值为<code>false</code>，更罗嗦的说法是<code>(!true==false)==true</code>，虽然表达方式不一样，不过我们一般会采用简洁的布尔表达式，就像用x来表示<code>x==true</code>。</p>
<p>布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s != <span class="string">&quot;&quot;</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其中s[0]操作如果应用于空字符串将会导致panic异常。</p>
<p>因为<code>&amp;&amp;</code>的优先级比<code>||</code>高（助记：<code>&amp;&amp;</code>对应逻辑乘法，<code>||</code>对应逻辑加法，乘法比加法优先级要高），下面形式的布尔表达式是不需要加小括弧的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span> ||</span><br><span class="line">		<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span> ||</span><br><span class="line"><span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line">  <span class="comment">// ... ASCII letter or digit...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>布尔值并不会瘾式转换为数字值0或1， 反之亦然。 必须使用一个显式的if语句辅助转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  i = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果需要经常做类似的转换, 包装成一个函数更方便</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">btoi</span><span class="params">(b <span class="keyword">bool</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> b &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>数字到布尔类型的逆转换则非常简单， 不过为了保持对称，我们可以包装一个函数:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itob</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> i != <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>



<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>一个字符串是一个不可改变的字节序列。 字符串可以包含任意的数据，包括byte值0， 但是通常是用来包含人类刻度的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列</p>
<p>内置的len函数可以返回一个字符串的字节数目 (不是rune字符数目)，索引操作s[i]返回第i个字节的字节值，i必须满足 0 &lt; i &lt; len(s)条件约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))					<span class="comment">// 12</span></span><br><span class="line">fmt.Println(s[<span class="number">0</span>], s[<span class="number">7</span>])			<span class="comment">// 104 119</span></span><br></pre></td></tr></table></figure>

<p>将采用0作为开始位置，采用len(s)作为结束的位置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s[:<span class="number">5</span>])				<span class="comment">// &quot;hello&quot;</span></span><br><span class="line">fmt.Println(s[<span class="number">7</span>:])				<span class="comment">// &quot;world&quot;</span></span><br><span class="line">fmt.Println(s[:])					<span class="comment">// &quot;hello, world&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中+操作符将两个字符串连接构造一个新字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;goodbye&quot;</span> + s[<span class="number">5</span>:]) <span class="comment">// &quot;goodbye, world&quot;</span></span><br></pre></td></tr></table></figure>



<p>字符串可以用==和&lt;进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。<strong>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。</strong></p>
<p>将一个字符串追加到另一个字符串:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;left foot&quot;</span></span><br><span class="line">t := s</span><br><span class="line">s += <span class="string">&quot;, right foot&quot;</span></span><br></pre></td></tr></table></figure>

<p>这并不会导致原始的字符串值被改变，但是变量s将因为+=语句持有一个新的字符串值，但是t依然是包含原先的字符串值。</p>
<p><strong>字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是不能修改字符串是由byte字节组成，所以字符串的长度是byte字节的长度。</strong></p>
<p><strong>Go语言源文件总是用UTF8编码， 并且Go语言的文本字符串也是以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中</strong></p>
<p>制表符等是常见的ASCII控制代码的转义方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\a      响铃</span><br><span class="line">\b      退格</span><br><span class="line">\f      换页</span><br><span class="line">\n      换行</span><br><span class="line">\r      回车</span><br><span class="line">\t      制表符</span><br><span class="line">\v      垂直制表符</span><br><span class="line">\&#x27;      单引号（只用在 &#x27;\&#x27;&#x27; 形式的rune符号面值中）</span><br><span class="line">\&quot;      双引号（只用在 &quot;...&quot; 形式的字符串面值中）</span><br><span class="line">\\      反斜杠</span><br></pre></td></tr></table></figure>



<p>Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等），unicode/utf8包则提供了用于rune字符序列的UTF8编码和解码的功能。</p>
<p>将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="keyword">string</span>(<span class="number">65</span>))						<span class="comment">// A</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(<span class="number">0x4eac</span>))				<span class="comment">// 京</span></span><br></pre></td></tr></table></figure>



<p>标准库中有4个包对字符串处理尤为重要: <strong>bytes、strings、strconv和unicode包</strong>。 </p>
<p>strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能</p>
<p>bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。</p>
<p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p>
<p>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</p>
<p>一个字符串是包含只读字节的数组， 一旦创建，是不可变的。</p>
<p>一个字节slice的元素则可以自由修改</p>
<p>字符串和字节slice之间可以相互转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">b := []<span class="keyword">byte</span>(s)</span><br><span class="line">s2 := <span class="keyword">string</span>(b)</span><br></pre></td></tr></table></figure>

<p>从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变。将一个字节slice转换到字符串的string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的。</p>
<h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Go语言中使用fmt.Sprintf格式化字符串并赋值给新串 */</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// %d 表示整形数字, %s 表示字符串</span></span><br><span class="line">    <span class="keyword">var</span> stockcode=<span class="number">123</span></span><br><span class="line">    <span class="keyword">var</span> enddate=<span class="string">&quot;2020-12-31&quot;</span></span><br><span class="line">    <span class="keyword">var</span> url=<span class="string">&quot;Code=%d&amp;endDate=%s&quot;</span></span><br><span class="line">    <span class="keyword">var</span> target_url=fmt.Sprintf(url, stockcode, enddate)</span><br><span class="line">    fmt.Println(target_url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。</p>
<p>使用语法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14159</span></span><br></pre></td></tr></table></figure>



<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组。</p>
<p>数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。    </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span>					<span class="comment">// 数组长度为3</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>])				<span class="comment">// 打印数组第一个元素</span></span><br><span class="line">fmt.Println(a[<span class="built_in">len</span>(a)<span class="number">-1</span>])		<span class="comment">// 打印数组最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组的下标和元素</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅打印数组的元素</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> r [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(r[<span class="number">2</span>])				<span class="comment">// &quot;0&quot;</span></span><br></pre></td></tr></table></figure>



<p>在数组字面值中，如果在数组的长度位置出现的是 “…” 省略号，则表示数组的长度是根据初始化值的个数来计算。 因此， 上面的q数组的定义可以简化为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, q)				<span class="comment">// &quot;[3]int&quot;</span></span><br></pre></td></tr></table></figure>



<p>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。 <strong>数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">q = [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;				<span class="comment">// compile error: cannot assign [4]int to [3]int</span></span><br></pre></td></tr></table></figure>



<p>数组、slice、map和结构体字面值的写法都很相似。 上面的形式是直接提供顺序初始化值序列，但是也<strong>可以指定一个索引和对应值列表的方式初始化</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Currency <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	USD Currency = <span class="literal">iota</span>			<span class="comment">// 美元</span></span><br><span class="line">    EUR							<span class="comment">// 欧元</span></span><br><span class="line">    GBP							<span class="comment">// 英镑</span></span><br><span class="line">    RMB							<span class="comment">// 人民币</span></span><br><span class="line">)</span><br><span class="line">symbol := [...]<span class="keyword">string</span>&#123;USD: <span class="string">&quot;$&quot;</span>, EUR: <span class="string">&quot;€&quot;</span>, GBP: <span class="string">&quot;￡&quot;</span>, RMB: <span class="string">&quot;￥&quot;</span>&#125;</span><br><span class="line">fmt.Println(RMB, symbol[RMB])	<span class="comment">// &quot;3 ￥&quot;</span></span><br></pre></td></tr></table></figure>



<p>在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化。例如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">-1</span>&#125;			<span class="comment">// &quot;[0 0 0 0 0  ... -1]&quot;</span></span><br></pre></td></tr></table></figure>

<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>
<p>未指定声明的，初始值为0。</p>
<h4 id="引用类型-1"><a href="#引用类型-1" class="headerlink" title="引用类型"></a>引用类型</h4><h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。</p>
<p>数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。</p>
<p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。</p>
<p>如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(summer[:<span class="number">20</span>]) <span class="comment">// panic: out of rangeendlessSummer := summer[:5] // extend a slice (within capacity)fmt.Println(endlessSummer)  // &quot;[June July August September October]&quot;</span></span><br></pre></td></tr></table></figure>

<p>slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名</p>
<p>和数组不同的是，slice之间不能比较，因此我们<strong>不能使用==操作符来判断两个slice是否含有全部相等元素。</strong></p>
<p><strong>一个零值的slice等于nil。</strong>一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]。与任意类型的nil值一样，我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>    <span class="comment">// len(s) == 0, s == nils = nil        // len(s) == 0, s == nils = []int(nil) // len(s) == 0, s == nils = []int&#123;&#125;    // len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>



<p>内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)<span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// same as make([]T, cap)[:len]</span></span><br></pre></td></tr></table></figure>



<p>内置append函数可以追加多个元素，甚至追加一个slice</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x []intx = <span class="built_in">append</span>(x, <span class="number">1</span>)x = <span class="built_in">append</span>(x, <span class="number">2</span>, <span class="number">3</span>)x = <span class="built_in">append</span>(x, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)x = <span class="built_in">append</span>(x, x...)				<span class="comment">// append the slice xfmt.Println(x)						// &quot;[1 2 3 4 5 6 1 2 3 4 5 6]&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>哈希表是一种巧妙并且实用的数据结构。 它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。</p>
<p>在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以<strong>map可以通过测试key是否相等来判断是否已经存在。</strong></p>
<p>内置的make函数可以创建一个map</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)		<span class="comment">// mapping from strings to ints</span></span><br></pre></td></tr></table></figure>

<p>可以用map字面值的语法创建map，同时还可以指定一些最初的key/value</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;  <span class="string">&quot;age1&quot;</span>: <span class="number">18</span>,  <span class="string">&quot;age2&quot;</span>: <span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure>

<p>另一种创建空的Map表达式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Map中元素通过key下标语法访问</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">&quot;age1&quot;</span>] = <span class="number">18</span>fmt.Println(ages[<span class="string">&quot;age1&quot;</span>])   <span class="comment">// &quot;18&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用delete函数可以删除元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(ages, <span class="string">&quot;age1&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>即使某些元素不在map中也没有关系，失败时将返回0。</strong></p>
<p>map中元素并不是一个变量，因此不能对map的元素取址操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = &amp;ages[<span class="string">&quot;bob&quot;</span>]			<span class="comment">// compile error: cannot take address of map element</span></span><br></pre></td></tr></table></figure>

<p><strong>禁止对map元素取地址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</strong></p>
<p>遍历map中全部的key/value对的话，可以使用range风格的for循环实现，和之前的slice遍历语法类似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, age := <span class="keyword">range</span> ages &#123;  fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, age)&#125;</span><br></pre></td></tr></table></figure>

<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。</p>
<p>对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="string">&quot;age1&quot;</span>: <span class="number">19</span>,</span><br><span class="line">		<span class="string">&quot;age2&quot;</span>: <span class="number">20</span>,</span><br><span class="line">		<span class="string">&quot;age4&quot;</span>: <span class="number">19</span>,</span><br><span class="line">		<span class="string">&quot;age3&quot;</span>: <span class="number">20</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> names []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> name := <span class="keyword">range</span> ages &#123;</span><br><span class="line">		names = <span class="built_in">append</span>(names, name)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Strings(names)</span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\t%d\n&quot;</span>, name, ages[name])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age1    19</span><br><span class="line">age2    20</span><br><span class="line">age3    20</span><br><span class="line">age4    19</span><br></pre></td></tr></table></figure>



<p><strong>map类型的零值是nil， 也就是没有引用任何哈希表。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ages <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">fmt.Println(ages == <span class="literal">nil</span>)			<span class="comment">// &quot;true&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ages) == <span class="number">0</span>)		<span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<p>向一个nil值的map存入元素将导致一个panic异常，在向map存数据前必须先创建map</p>
<p>列如，元素类型是一个数字，可能需要区分一个已存在的0，和不存在返回零值的0，可以像下面</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age, ok := ages[<span class="string">&quot;bbb&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">/* &quot;bob&quot; is not a key in this map; age == 0. */</span>&#125;</span><br></pre></td></tr></table></figure>

<p>经常看到两个结合起来使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := ages[<span class="string">&quot;bob&quot;</span>]; !ok &#123;<span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>



<p>和slice一样，map之间不能进行相等比较；唯一的例外是和nil进行比较。要判断两个map是否包含相同的key和value， 必须通过一个循环实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> equal(x, y <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="keyword">bool</span> &#123;  <span class="keyword">if</span> <span class="built_in">len</span>(x) != <span class="built_in">len</span>(y) &#123;    <span class="keyword">return</span> <span class="literal">false</span>  &#125;  <span class="keyword">for</span> k, xv := <span class="keyword">range</span> x &#123;    <span class="keyword">if</span> yv, ok := y[k]; !ok || yv != xv &#123;      <span class="keyword">return</span> <span class="literal">false</span>    &#125;  &#125;  <span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>



<p>Go语言中并没有提供一个set类型，但是map中的key也是不相同的，可以用map实现类似set的功能。</p>
<p>Map的value类型也可以是一个聚合类型，比如是一个map或slice。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> graph = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br></pre></td></tr></table></figure>



<h5 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h5><p>补充！！！</p>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>区别于C/C++中的指针，Go语言中的指针不能进行偏移和运算，是安全指针。</p>
<p>Go语言中的指针需要先知道3个概念：指针地址、指针类型和指针取值。</p>
<p><strong>Go语言中的函数传参都是值拷贝，</strong>当我们想要修改某个变量的时候，我们可以创建一个指向该变量地址的指针变量。</p>
<p><strong>传递数据使用指针，而无须拷贝数据。</strong></p>
<p>Go语言中的指针操作非常简单，只需要记住两个符号：<code>&amp;</code>（取地址）和<code>*</code>（根据地址取值）。</p>
<h5 id="指针地址和指针类型"><a href="#指针地址和指针类型" class="headerlink" title="指针地址和指针类型"></a>指针地址和指针类型</h5><p>每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用&amp;字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型<code>（int、float、bool、string、array、struct）</code>都有对应的指针类型，如：<code>*int、*int64、*string</code>等。</p>
<p>取变量指针的语法如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr := &amp;v					<span class="comment">// v的类型为T</span></span><br></pre></td></tr></table></figure>

<p>解:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v:   代表被取地址的变量，类型为Tptr: 用于接收地址的变量，ptr的类型就为*T，称做T的指针类型。*代表指针。</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  a := <span class="number">10</span>  b := &amp;a  fmt.Printf(<span class="string">&quot;a:%d ptr:%p\n&quot;</span>, a, &amp;a) <span class="comment">// a:10 ptr:0xc00001a078  fmt.Printf(&quot;b:%p type:%T\n&quot;, b, b) // b:0xc00001a078 type:*int  fmt.Println(&amp;b)										 // 0xc00000e018&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p><strong>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体，每个值称为结构体的成员。</strong></p>
<p>下面两个语句声明了一个叫Employee的命名的结构体类型，并且声明了一个Employee类型的变量dilbert:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  ID						<span class="keyword">int</span>  Name					<span class="keyword">string</span>  Address 			<span class="keyword">string</span>  DoB						time.Time  Position			<span class="keyword">string</span>  Salary				<span class="keyword">int</span>  ManagerID			<span class="keyword">int</span>&#125;<span class="keyword">var</span> dilbert Employee</span><br></pre></td></tr></table></figure>

<p><strong>dilbert结构体变量的成员可以通过点操作符访问</strong>，比如dilbert.Name和dilbert.DoB。因为dilbert是一个变量，它所有的成员也同样是变量，可以直接对每个成员赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dilbert.Salary -= <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>或者对成员取地址，然后通过指针访问</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position := &amp;dilbert.Position*position = <span class="string">&quot;Senior &quot;</span> + *position</span><br></pre></td></tr></table></figure>

<p>点操作符也可以和指向结构体的指针一起工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> employeeOfTheMonth *Employee = &amp;dilbertemployeeOfTheMonth.Position += <span class="string">&quot; (proactive team player)&quot;</span></span><br></pre></td></tr></table></figure>

<p>相当于下面语句</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*employeeOfTheMonth).Position += <span class="string">&quot; (proactive team player)&quot;</span></span><br></pre></td></tr></table></figure>



<p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行，就像下面的Name和Address成员那样:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID						<span class="keyword">int</span></span><br><span class="line">  Name, Address	<span class="keyword">string</span></span><br><span class="line">  DoB						time.Time</span><br><span class="line">  Position			<span class="keyword">string</span></span><br><span class="line">  Salary				<span class="keyword">int</span></span><br><span class="line">  ManagerID			<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dilbert Employee</span><br></pre></td></tr></table></figure>



<p><strong>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。</strong> 一个结构体可能同时包含导出和未导出的成员。</p>
<p>一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）</p>
<p>结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。</p>
<p>如果结构体没有任何成员的话就是空结构体，写作struct{}。它的大小为0，也不包含任何信息，但是有时候依然是有价值的。</p>
<p><strong>结构体字面值</strong></p>
<p>结构体值可以用结构体字面值表示，结构体字面值可以指定每个成员值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123; X, Y <span class="keyword">int</span> &#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>另外一种写法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br></pre></td></tr></table></figure>

<p>在这种形式的结构体字面值写法中，如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要。</p>
<p>两种不同形式的写法不能混合使用。</p>
<p><strong>如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AwardAnnualRaise</span><span class="params">(e *Employee)</span></span> &#123;</span><br><span class="line">    e.Salary = e.Salary * <span class="number">105</span> / <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为结构体通常通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pp := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>它和下面的语句是等价的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pp := <span class="built_in">new</span>(Point)</span><br><span class="line">*pp = Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>



<p>结构体也是可以比较的，两个结构体将可以使用==或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">int</span> &#125;</span><br><span class="line"></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) <span class="comment">// &quot;false&quot;</span></span><br><span class="line">fmt.Println(p == q)                   <span class="comment">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数特点"><a href="#函数特点" class="headerlink" title="函数特点"></a>函数特点</h4><ul>
<li><p>无需声明原型</p>
</li>
<li><p>支持不定变参</p>
</li>
<li><p>支持多返回值</p>
</li>
<li><p>支持命名返回参数</p>
</li>
<li><p>支持匿名函数和闭包</p>
</li>
<li><p>函数也是一种类型，一个函数可以赋值给变量</p>
</li>
<li><p>不支持嵌套 (nested) 一个包不能有两个名字一样的函数</p>
</li>
<li><p>不支持重载 (overload)</p>
</li>
<li><p>不支持默认参数 (default parameter)</p>
<p>​            </p>
</li>
</ul>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span> <span class="params">(result-list)</span></span> &#123;    body&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hypot</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;  <span class="keyword">return</span> math.Sqrt(x*x + y*y)&#125;fmt.Println(hypot(<span class="number">3</span>, <span class="number">4</span>))					<span class="comment">// &quot;5&quot;</span></span><br></pre></td></tr></table></figure>

<p>x和y是形参名，3和4是调用时的传入的实参，函数返回了一个float64类型的值。 返回值也可以像形式参数一样被命名。</p>
<p>可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数签名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mathfunc Sin(x <span class="keyword">float64</span>) float <span class="comment">//implemented in assembly language</span></span><br></pre></td></tr></table></figure>



<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a><strong>值传递</strong></h5><p>指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">       ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a><strong>引用传递</strong></h5><p>是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义相互交换值的函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    temp = *x <span class="comment">/* 保存 x 的值 */</span></span><br><span class="line">    *x = *y   <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">    *y = temp <span class="comment">/* 将 temp 值赋给 y*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用 swap() 函数</span></span><br><span class="line"><span class="comment">        &amp;a 指向 a 指针，a 变量的地址</span></span><br><span class="line"><span class="comment">        &amp;b 指向 b 指针，b 变量的地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的拷贝。引用传递是地址的拷贝，一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。</p>
<p>map、slice、chan、指针、interface默认以引用的方式传递。</p>
<h5 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a><strong>函数参数传递</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(fn <span class="keyword">func</span>()</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数类型</span></span><br><span class="line"><span class="keyword">type</span> FormatFunc <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">format</span><span class="params">(fn FormatFunc, s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fn(s, x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := test(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="number">100</span> &#125;)				<span class="comment">// 直接将匿名函数当参数</span></span><br><span class="line">	</span><br><span class="line">	s2 := format(<span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>, x, y <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Sprintf(s, x, y)</span><br><span class="line">	&#125;, <span class="string">&quot;%d, %d&quot;</span>, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="built_in">println</span>(s1, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该程序输出:</span></span><br><span class="line"><span class="comment">100 10, 20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="不定参数传值"><a href="#不定参数传值" class="headerlink" title="不定参数传值"></a><strong>不定参数传值</strong></h4><p>函数的参数不是固定，后面的类型是固定的。 (可变参数)</p>
<p>golang可变参数本质上就是slice。</p>
<p>在参数赋值时可以不用用一个一个的赋值，可以直接传递一个数组或者切片，特别注意的是在参数后加上“…”即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;    <span class="comment">//0个或多个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;    <span class="comment">//1个或多个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, args ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;    <span class="comment">//2个或多个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中args是一个slice，我们可以通过arg[index]依次访问所有参数,通过len(arg)来判断传递参数的个数.</p>
<p>使用slice对象做变参时，必须展开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s <span class="keyword">string</span>, n ...<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;</span><br><span class="line">        x += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(s, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    res := test(<span class="string">&quot;sum: %d&quot;</span>, s...)    <span class="comment">// slice... 展开slice</span></span><br><span class="line">    <span class="built_in">println</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="任意类型的不定参数"><a href="#任意类型的不定参数" class="headerlink" title="任意类型的不定参数"></a><strong>任意类型的不定参数</strong></h4><p>函数的参数和每个参数的类型都不是固定的</p>
<p>用interface{}传递任意类型数据是Go语言的惯例用法，而且interface{}是类型安全的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p><code>_</code> 标识符，用来忽略函数的某个返回值。</p>
<p>Go 的返回值可以被命名， 返回值的名称应当具有一定意义。</p>
<p>没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    &#123; <span class="comment">// 不能在一个级别，引发 &quot;z redeclared in this block&quot; 错误。</span></span><br><span class="line">        <span class="keyword">var</span> z = x + y</span><br><span class="line">        <span class="comment">// return   // Error: z is shadowed during return</span></span><br><span class="line">        <span class="keyword">return</span> z <span class="comment">// 必须显式返回。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>命名返回参数允许 <code>defer</code> 延迟调用通过闭包读取和修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mian</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	z += <span class="number">100</span></span><br><span class="line">  &#125;()</span><br><span class="line">  z = x + y</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">103</span><br></pre></td></tr></table></figure>



<p>显示 <code>return</code> 返回前，会先修改命名返回参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(z)			<span class="comment">// 输出: 203</span></span><br><span class="line">  &#125;()</span><br><span class="line">  z = x + y</span><br><span class="line">  <span class="keyword">return</span> z + <span class="number">100</span>		<span class="comment">// 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (return)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(add(<span class="number">1</span>, <span class="number">2</span>))	<span class="comment">// 输出: 203</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">203</span><br><span class="line">203</span><br></pre></td></tr></table></figure>



<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>在Go里面，函数可以像普通变量一样被传递或使用，Go语言支持随时在代码里定义匿名函数。</p>
<p>匿名函数由一个不带函数名的函数声明和函数体组成。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>  <span class="string">&quot;math&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  getSqrt := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;    <span class="keyword">return</span> math.Sqrt(a)  &#125;  fm.Println(getSqrt(<span class="number">4</span>))&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>



<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p>闭包（Closure），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p>
<p><strong>Go实现闭包</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  i := <span class="number">0</span></span><br><span class="line">  b := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := a()</span><br><span class="line">  c()</span><br><span class="line">  c()</span><br><span class="line">  c()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>



<h4 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h4><p><strong>递归，就是在运行的过程中调用自己。</strong></p>
<p><strong>一个函数调用自己， 就叫做递归函数。</strong></p>
<p>构成递归具备的条件：</p>
<ol>
<li>子问题须与原始问题为同样的事，且更为简单。</li>
<li>不能无限制地调用本身，须有个出口，化简为非递归状况处理。</li>
</ol>
<p><strong>数字阶乘</strong></p>
<p>一个正整数的阶乘 (factorial) 是所有小于及等于该数的正整数的积，并且0的阶乘为1。自然数n的阶乘写作n!。1808年，基斯顿·卡曼引进这个表示法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i * factorial(i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">7</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Factorial of %d is %d\n&quot;</span>, i, factorial((i)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Factorial of 7 is 5040</span><br></pre></td></tr></table></figure>



<p><strong>裴波那契数列(Fibonacci)</strong></p>
<p>这个数列从第3项开始，每一项都等于前两项之和。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">fibonaci</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;	<span class="keyword">if</span> i == <span class="number">0</span> &#123;		<span class="keyword">return</span> <span class="number">0</span>	&#125;	<span class="keyword">if</span> i == <span class="number">1</span> &#123;		<span class="keyword">return</span> <span class="number">1</span>	&#125;	<span class="keyword">return</span> fibonaci(i<span class="number">-1</span>) + fibonaci(i<span class="number">-2</span>)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	<span class="keyword">var</span> i <span class="keyword">int</span>	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;		fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, fibonaci(i))	&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0112358132134</span><br></pre></td></tr></table></figure>



<h4 id="延迟调用-defer"><a href="#延迟调用-defer" class="headerlink" title="延迟调用 (defer)"></a>延迟调用 (defer)</h4><h5 id="defer特性"><a href="#defer特性" class="headerlink" title="defer特性"></a>defer特性</h5><ol>
<li>关键字 defer 用于注册延迟调用。</li>
<li>这些调用直到 return 前才被执。因此，可以用来做资源清理。</li>
<li>多个defer语句，<strong>按先进后出的方式执行。</strong></li>
<li>defer语句中的变量，在defer声明时就决定了。</li>
</ol>
<h5 id="defer用途"><a href="#defer用途" class="headerlink" title="defer用途"></a>defer用途</h5><ol>
<li>关闭文件句柄</li>
<li>锁资源释放</li>
<li>数据库连接释放</li>
</ol>
<p><strong>多个 defer 注册，按 FILO 次序执行 ( 先进后出 ) 原则。</strong> 哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="number">100</span> / x) <span class="comment">// div0 异常未被捕获，逐步往外传递，最终终止进程</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">println</span>(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">b</span><br><span class="line">a</span><br><span class="line">panic: runtime error: integer divide by zero</span><br></pre></td></tr></table></figure>



<p>defer后面的语句在执行的时候，函数调用的参数会被保存起来，但是不执行。也就是复制了一份。</p>
<p><strong>延迟调用参数在注册时求值或复制，可用指针或闭包 “延迟” 读取。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">10</span>, <span class="number">100</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;defer x = %v, y = %v\n&quot;</span>, i, y) <span class="comment">// y 闭包引用</span></span><br><span class="line">	&#125;(x) <span class="comment">// x 被复制</span></span><br><span class="line"></span><br><span class="line">	x += <span class="number">10</span></span><br><span class="line">	y += <span class="number">20</span></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;x = &quot;</span>, x, <span class="string">&quot;y = &quot;</span>, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x =  20 y =  120</span><br><span class="line">defer x = 10, y = 120</span><br></pre></td></tr></table></figure>



<h5 id="defer-与-return"><a href="#defer-与-return" class="headerlink" title="defer 与 return"></a>defer 与 return</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>在有具名返回值的函数中 (这里具名返回值为 i)，执行 return 2的时候实际上已经将i 的值重新赋值为2。 所以defer closure输出结果为2 而不是1。</strong></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>Golang 没有结构化异常，使用 <code>panic</code> 抛出错误，<code>recover</code> 捕捉错误。</p>
<p>异常的使用场景简单描述：<strong>Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。</strong></p>
<h5 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h5><ol>
<li>内置函数</li>
<li>假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行</li>
<li>返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行</li>
<li>直到goroutine整个退出，并报告错误</li>
</ol>
<h5 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h5><ol>
<li><p>内置函数</p>
</li>
<li><p>用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为</p>
</li>
<li><p>一般的调用建议</p>
<p>a. 在defer函数中，通过recover来终止一个goroutine的panicking过程，从而恢复正常代码的执行</p>
<p>b. 可以获取通过panic传递的error</p>
</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li>利用 recover 处理 panic 指令， defer 必须在painc 之前定义， 另外 recover 只有在 defer 调用的函数中才有效。 否则当 <code>panic</code> 时，recover无法捕获 painc ， 无法防止 panic 扩散。</li>
<li><strong>recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。</strong></li>
<li>多个 defer 会形成 defer 栈， 后定义的 defer 语句会被最先调用。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainfunc main() &#123;	test()&#125;<span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;			<span class="built_in">println</span>(err.(<span class="keyword">string</span>)) <span class="comment">// 将 interface&#123;&#125; 转型为具体类型		&#125;	&#125;()	panic(&quot;panic error!&quot;)&#125;</span></span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic error!</span><br></pre></td></tr></table></figure>



<p><strong><code>painc</code> 、 <code>recover</code> 参数类型为interface{}， 因此可抛出任何类型对象。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span><span class="title">func</span> <span class="title">recover</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;		fmt.Println(<span class="built_in">recover</span>())	&#125;()	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;		<span class="built_in">panic</span>(<span class="string">&quot;defer panic&quot;</span>)	&#125;()	<span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	test()&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defer panic</span><br></pre></td></tr></table></figure>



<p><strong>捕获函数 recover 只有在延迟调用内直接调用才会终止错误， 否则总是返回nil。</strong> 任何未捕获的错误都会沿调用堆栈向外传递。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;		fmt.Println(<span class="built_in">recover</span>()) <span class="comment">// 有效	&#125;()	defer recover()              // 无效	defer fmt.Println(recover()) // 无效	defer func() &#123;		func() &#123;			println(&quot;defer inner&quot;)			recover() // 无效		&#125;()	&#125;()	panic(&quot;test panic&quot;)&#125;func main() &#123;	test()&#125;</span></span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defer inner&lt;nil&gt;test panic</span><br></pre></td></tr></table></figure>



<p><strong>Go实现 Try catch 的异常处理</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">Try</span><span class="params">(fun <span class="keyword">func</span>()</span>, <span class="title">handler</span> <span class="title">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;			handler(err)		&#125;	&#125;()	fun()&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	Try(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;		<span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)	&#125;, <span class="function"><span class="keyword">func</span><span class="params">(err <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;		fmt.Println(err)	&#125;)&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test panic</span><br></pre></td></tr></table></figure>

<p><strong><code>panic</code> 和 <code>error</code> 使用经验， 导致关键流程出现不可修复性错误的使用 <code>panic</code> ，其他使用 <code>error</code>。</strong></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Golang 方法总是绑定对象实例， 并隐式将实例作为第一实参 (receiver)。</p>
<ul>
<li><strong>只能为当前包内命名类型定义方法</strong></li>
<li>参数 <code>receiver</code> 可任意命名。 如方法中未曾使用， 可省略参数名。</li>
<li>参数 <code>receiver</code> 类型可以是 T 或 *T。 基类型 T 不能是接口或指针。</li>
<li>不支持方法重载， <code>receiver</code> 只是参数签名的组成部分。</li>
<li>可用实例 <code>value</code> 或 <code>pointer</code> 调用全部方法， 编译器自动转换。</li>
</ul>
<p>一个方法就是一个包含了接受者的函数， 接受者可以是命名类型或者结构体类型的一个值或者是一个指针。</p>
<p>所有给定类型的方法属于该类型的方法集。</p>
<h5 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recevier <span class="keyword">type</span>)</span> <span class="title">methodName</span><span class="params">(参数列表)</span> <span class="params">(返回值列表)</span></span> &#123;&#125;参数和返回值可以省略</span><br></pre></td></tr></table></figure>

<p>几种使用方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> maintype Test <span class="keyword">struct</span>&#123;&#125;<span class="comment">// 无参数, 无返回值func (t Test) method0() &#123;&#125;// 单参数, 无返回值func (t Test) method1(i int)&#123;&#125;// 多参数, 无返回值func (t Test) method2(x, y int)&#123;&#125;// 无参数, 单返回值func (t Test) method3() (i int)&#123;  return &#125;// 多参数, 多返回值func (t Test) method4(x, y int) (z int, err error) &#123;&#125;// 无参数, 无返回值func (t *Test) method5() &#123;&#125;// 单参数, 无返回值func (t *Test) method6(i int) &#123;&#125;// 多参数, 无返回值func (t *Test) method7(x, y int) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>定义一个结构类型和该类型的一个方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="keyword">string</span></span><br><span class="line">	Email <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">Notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v : %v \n&quot;</span>, u.Name, u.Email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 值类型调用方法</span></span><br><span class="line">	u1 := User&#123;<span class="string">&quot;golang&quot;</span>, <span class="string">&quot;test@golang.com&quot;</span>&#125;</span><br><span class="line">	u1.Notify()</span><br><span class="line">	<span class="comment">// 指针类型调用方法</span></span><br><span class="line">	u2 := User&#123;<span class="string">&quot;go&quot;</span>, <span class="string">&quot;go@go.cn&quot;</span>&#125;</span><br><span class="line">	u3 := &amp;u2</span><br><span class="line">	u3.Notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">golang : test@golang.com </span><br><span class="line">go : go@go.cn</span><br></pre></td></tr></table></figure>



<h5 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h5><p>如类型S包含匿名字段 <code>*T</code> ，则 S 和 <code>*S</code> 方法集包含 <code>T + *T</code> 方法。</p>
<p>这条规则说的是当我们嵌入一个类型的指针， 嵌入类型的接受者为值类型或指针类型的方法将被提升， 可以被外部类型的值或者指针调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">	T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">testT</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;如类型 S 包含匿名类型 *T, 则 S 和 *S 方法集包含 T 方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">testP</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;如类型 S 包含匿名字段 *T, 则 S 和 *S 方法集合包含 *T 方法&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := S&#123;T&#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">	s2 := &amp;s1</span><br><span class="line">	fmt.Printf(<span class="string">&quot;s1 is : %v\n&quot;</span>, s1)</span><br><span class="line">	s1.testT()</span><br><span class="line">	s1.testP()</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;s2 is : %v\n&quot;</span>, s2)</span><br><span class="line">	s2.testT()</span><br><span class="line">	s2.testP()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><p>Golang 表达式： 根据调用者不同，方法分为两种表现形式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.method(args...) ---&gt; &lt;<span class="keyword">type</span>&gt;.<span class="keyword">func</span>(instance, args...)</span><br></pre></td></tr></table></figure>

<p><strong>前者称为 method value， 后者 method expression则须显式传参。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	id   <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *User)</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p, %v\n&quot;</span>, self, self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">	u.Test()</span><br><span class="line"></span><br><span class="line">	mValue := u.Test</span><br><span class="line">	mValue() <span class="comment">// 隐式传递 receiver</span></span><br><span class="line"></span><br><span class="line">	mExpression := (*User).Test</span><br><span class="line">	mExpression(&amp;u) <span class="comment">// 显式传递 receiver</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xc00000c030, &amp;&#123;1 Tom&#125;</span><br><span class="line">0xc00000c030, &amp;&#123;1 Tom&#125;</span><br><span class="line">0xc00000c030, &amp;&#123;1 Tom&#125;</span><br></pre></td></tr></table></figure>



<p>需要注意，method value 会复制 receiver</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	id   <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self User)</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u := User&#123;<span class="number">1</span>, <span class="string">&quot;Tom&quot;</span>&#125;</span><br><span class="line">	mValue := u.Test <span class="comment">// 立即复制 receiver, 因为不是指针类型, 不受后续修改影响。</span></span><br><span class="line"></span><br><span class="line">	u.id, u.name = <span class="number">2</span>, <span class="string">&quot;Jack&quot;</span></span><br><span class="line">	u.Test()</span><br><span class="line"></span><br><span class="line">	mValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;2 Jack&#125;</span><br><span class="line">&#123;1 Tom&#125;</span><br></pre></td></tr></table></figure>



<h5 id="error-案例"><a href="#error-案例" class="headerlink" title="error 案例"></a>error 案例</h5><p><strong>返回异常</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCircleArea</span><span class="params">(radius <span class="keyword">float32</span>)</span> <span class="params">(area <span class="keyword">float32</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 构建个异常对象</span></span><br><span class="line">		err = errors.New(<span class="string">&quot;半径不能为负数&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	area = <span class="number">3.14</span> * radius * radius</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	area, err := getCircleArea(<span class="number">-5</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(area)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">半径不能为负数</span><br></pre></td></tr></table></figure>



<p><strong>自定义 error</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport (	<span class="string">&quot;fmt&quot;</span>	<span class="string">&quot;os&quot;</span>	<span class="string">&quot;time&quot;</span>)<span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;	path       <span class="keyword">string</span>	op         <span class="keyword">string</span>	createTime <span class="keyword">string</span>	message    <span class="keyword">string</span>&#125;<span class="function"><span class="keyword">func</span> <span class="params">(p *PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;path=%s \nop=%s \ncreateTime=%s \nmessage=%s&quot;</span>, p.path, p.op, p.createTime, p.message)&#125;<span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;	file, err := os.Open(filename)	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;		<span class="keyword">return</span> &amp;PathError&#123;			path:       filename,			op:         <span class="string">&quot;read&quot;</span>,			message:    err.Error(),			createTime: fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, time.Now()),		&#125;	&#125;	<span class="keyword">defer</span> file.Close()	<span class="keyword">return</span> <span class="literal">nil</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	err := Open(<span class="string">&quot;/Users/ccccc/text.txt&quot;</span>)	<span class="keyword">switch</span> v := err.(<span class="keyword">type</span>) &#123;	<span class="keyword">case</span> *PathError:		fmt.Println(<span class="string">&quot;get path error,&quot;</span>, v)	<span class="keyword">default</span>:		<span class="keyword">return</span>	&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get path error, path=/Users/ccccc/text.txt op=read createTime=2021-10-10 20:41:17.694993 +0800 CST m=+0.000111814 message=open /Users/ccccc/text.txt: no such file or directory</span><br></pre></td></tr></table></figure>







<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h4><h5 id="go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段"><a href="#go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段" class="headerlink" title="go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段"></a><strong>go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段</strong></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	sex  <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Person</span><br><span class="line">	id   <span class="keyword">int</span></span><br><span class="line">	addr <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	s1 := Student&#123;Person&#123;<span class="string">&quot;Wu&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">24</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">	s2 := Student&#123;Person: Person&#123;<span class="string">&quot;Wu&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">24</span>&#125;&#125;</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">	s3 := Student&#123;Person: Person&#123;name: <span class="string">&quot;Wu&quot;</span>&#125;&#125;</span><br><span class="line">	fmt.Println(s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;Wu man 24&#125; 1 bj&#125;</span><br><span class="line">&#123;&#123;Wu man 24&#125; 0 &#125;</span><br><span class="line">&#123;&#123;Wu  0&#125; 0 &#125;</span><br></pre></td></tr></table></figure>



<h5 id="同名字段的情况"><a href="#同名字段的情况" class="headerlink" title="同名字段的情况"></a>同名字段的情况</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同名字段的情况</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	sex  <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Person</span><br><span class="line">	id   <span class="keyword">int</span></span><br><span class="line">	addr <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// 同名字段</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s Student</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值自己字段</span></span><br><span class="line">	s.name = <span class="string">&quot;Wu&quot;</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值父类同名字段</span></span><br><span class="line">	s.Person.name = <span class="string">&quot;Zhou&quot;</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;  0&#125; 0  Wu&#125;</span><br><span class="line">&#123;&#123;Zhou  0&#125; 0  Wu&#125;</span><br></pre></td></tr></table></figure>



<h5 id="所有的内置类型和自定义类型都是可以作为匿名字段去使用"><a href="#所有的内置类型和自定义类型都是可以作为匿名字段去使用" class="headerlink" title="所有的内置类型和自定义类型都是可以作为匿名字段去使用"></a>所有的内置类型和自定义类型都是可以作为匿名字段去使用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 人</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	sex <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">type</span> mystr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Person</span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">	mystr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := Student&#123;Person&#123;<span class="string">&quot;Wu&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">24</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;Wu man 24&#125; 1 bj&#125;</span><br></pre></td></tr></table></figure>



<h5 id="指针类型匿名字段"><a href="#指针类型匿名字段" class="headerlink" title="指针类型匿名字段"></a>指针类型匿名字段</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;	name <span class="keyword">string</span>	sex <span class="keyword">string</span>	age <span class="keyword">int</span>&#125;<span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;	*Person	id <span class="keyword">int</span>	addr <span class="keyword">int</span>&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;	s1 := Student&#123;&amp;Person&#123;<span class="string">&quot;Wu&quot;</span>, <span class="string">&quot;man&quot;</span>, <span class="number">24</span>&#125;, <span class="number">1</span>, <span class="string">&quot;bj&quot;</span>&#125;	fmt.Println(s1)	fmt.Println(s1.name)	fmt.Println(s1.Person.name)&#125;</span><br></pre></td></tr></table></figure>

<p>改程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;0xc000074150 1 bj&#125;WuWu</span><br></pre></td></tr></table></figure>



<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口 (interface) 定义了一个对象的行为规范， 只定义规范不实现，由具体的对象来实现规范的细节。</p>
<h5 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h5><p>在Go语言中接口 (interface) 是一种类型， 一种抽象的类型。</p>
<p>Interface 是一组method的集合， 是duck-type programming 的一种体现。 接口做的事情就像是定义一个协议(规则)。</p>
<p><strong>粗暴写接口</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mainimport <span class="string">&quot;fmt&quot;</span><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;<span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Say</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">&quot;喵喵&quot;</span> &#125;<span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;<span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Say</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">&quot;旺旺&quot;</span> &#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  c := Cat&#123;&#125;  fmt.Println(<span class="string">&quot;猫: &quot;</span>, c.Say())  d := Dog&#123;&#125;  fmt.Println(<span class="string">&quot;狗: &quot;</span>, d.Say())&#125;</span><br></pre></td></tr></table></figure>

<p>main函数中有明显的重复代码， 如果后续在增加动物， 代码会一直重复下去。</p>
<h5 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">接口是一个或多个方法签名的集合。</span><br><span class="line">任何类型的方法集中只要拥有该接口&#x27;对应的全部方法&#x27;签名。</span><br><span class="line">就表示它 &quot;实现&quot; 了该接口，无须在该类型上显式声明实现了哪个接口。</span><br><span class="line">这称为Structural Typing。</span><br><span class="line">所谓对应方法，是指有相同名称、参数列表 (不包括参数名) 以及返回值。</span><br><span class="line">当然，该类型还可以有其他方法。</span><br><span class="line"></span><br><span class="line">接口只有方法声明，没有实现，没有数据字段。</span><br><span class="line">接口可以匿名嵌入其他接口，或嵌入到结构中。</span><br><span class="line">对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。</span><br><span class="line">只有当接口存储的类型和对象都为nil时，接口才等于nil。</span><br><span class="line">接口调用不会做receiver的自动转换。</span><br><span class="line">接口同样支持匿名字段方法。</span><br><span class="line">接口也可实现类似OOP中的多态。</span><br><span class="line">空接口可以作为任何类型数据的容器。</span><br><span class="line">一个类型可实现多个接口。</span><br><span class="line">接口命名习惯以 er 结尾。 </span><br></pre></td></tr></table></figure>



<p>每个接口由数个方法组成，接口的定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型 <span class="keyword">interface</span> &#123;</span><br><span class="line">  方法名<span class="number">1</span> (参数列表<span class="number">1</span>) 返回值列表<span class="number">1</span></span><br><span class="line">  方法名<span class="number">2</span> (参数列表<span class="number">2</span>) 返回值列表<span class="number">2</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。</span><br><span class="line"></span><br><span class="line">2.方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</span><br><span class="line">3.参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。  </span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> writer <span class="keyword">interface</span> &#123;</span><br><span class="line">  Write([]<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h5><p><strong>值接收者接口</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;  move()&#125;<span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;<span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;  fmt.Println(<span class="string">&quot;狗狗&quot;</span>)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  <span class="keyword">var</span> x Mover  <span class="keyword">var</span> wangcai = dog&#123;&#125;  x = wangcai						<span class="comment">// x 可以接收dog类型  var fugui = &amp;dog&#123;&#125;    // fugui是 *dog 类型  x = fugui							// x可以接收*dog类型  x.move()							&#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>指针接收者接口</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  <span class="keyword">var</span> x Mover  <span class="keyword">var</span> wangcai = dog&#123;&#125;  x = wangcai						<span class="comment">// x 不可以接收dog类型  var fugui = &amp;dog&#123;&#125;    // fugui是 *dog 类型  x = fugui							// x可以接收*dog类型  x.move()							&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="类型与接口的关系"><a href="#类型与接口的关系" class="headerlink" title="类型与接口的关系"></a>类型与接口的关系</h5><p><strong>一个类型实现多个接口</strong></p>
<p>原则：接口间彼此独立，不知道对方的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口type Sayer interface &#123;  say()&#125;// Mover 接口type Mover interface &#123;  move()&#125;</span></span><br></pre></td></tr></table></figure>



<p>dog 既可以实现 <code>Sayer</code>接口 ， 也可以实现 <code>Mover</code>接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s: ssss\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s: mmmm\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Sayer</span><br><span class="line">  <span class="keyword">var</span> y Mover</span><br><span class="line">  <span class="keyword">var</span> a = dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">  x = a</span><br><span class="line">  y = a</span><br><span class="line">  x.say()</span><br><span class="line">  y.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>多个类型实现同一接口</strong></p>
<p>不同类型可以实现同一接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">  move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> car <span class="keyword">struct</span> &#123;</span><br><span class="line">  brand <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog 类型实现 Mover 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s: mmmm&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// car 类型实现 Mover 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c car)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%s: mmmm&quot;</span>, c.brand)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> x Mover</span><br><span class="line">  <span class="keyword">var</span> a = dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">  <span class="keyword">var</span> b = car&#123;brand: <span class="string">&quot;虾米&quot;</span>&#125;</span><br><span class="line">  x = a</span><br><span class="line">  x.move()</span><br><span class="line">  x = b</span><br><span class="line">  x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p>
<h5 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h5><p>接口与接口间可以通过嵌套创造出新的接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">    say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">    move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Sayer</span><br><span class="line">    Mover</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套得到的接口的使用与普通接口一样</span></span><br><span class="line"><span class="keyword">type</span> cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;ssss&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;mmmm&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x animal</span><br><span class="line">    x = cat&#123;name: <span class="string">&quot;花花&quot;</span>&#125;</span><br><span class="line">    x.move()</span><br><span class="line">    x.say()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h5><p>空接口是指没有定义任何方法的接口，因此任何类型都实现了空接口。</p>
<p>空接口类型的变量可以存储任意类型的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个空接口 x</span></span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    s := <span class="string">&quot;test data&quot;</span></span><br><span class="line">    x = s</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T value: %v\n&quot;</span>, x, x)</span><br><span class="line">    i := <span class="number">100</span></span><br><span class="line">    x = i</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T value: %v\n&quot;</span>, x, x)</span><br><span class="line">    b := <span class="literal">true</span></span><br><span class="line">    x = b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T value: %v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>空接口作为函数的参数</strong></p>
<p>使用空接口实现可以接收任意类型的函数对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T value: %v\n&quot;</span>, a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>空接口作为map的参数</strong></p>
<p>使用空接口实现可以保存任意值的字典</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;李白&quot;</span></span><br><span class="line">studentInfo[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">&quot;married&quot;</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure>



<p><strong>获取空接口值</strong></p>
<p>想要判断空接口中值，可以使用类型断言，语法如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure>

<p><code>x</code> 表示类型为 interface{} 的变量</p>
<p><code>T</code> 表示断言 x 可能是的类型</p>
<p>该语法返回两个参数，第一个参数是 x 转化为 T 类型后的变量， 第二个值是一个布尔值， 若为 true 则表示断言成功， false 则表示失败。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    x = <span class="string">&quot;data&quot;</span></span><br><span class="line">    v, ok := x.(<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;类型断言失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要断言多次，可以写 <code>if</code> 判断， 也可以用 <code>switch</code> 语句实现。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h4><h5 id="Go-runtime-介绍"><a href="#Go-runtime-介绍" class="headerlink" title="Go runtime 介绍"></a>Go runtime 介绍</h5><blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95056679">腾讯技术解析 runtime &amp; goroutine </a></p>
</blockquote>
<h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A. 进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。</span><br><span class="line">B. 线程是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。</span><br><span class="line">C. 一个进程可以创建和撤销多个线程; 同一个进程中的多个线程之间可以并发执行。  </span><br></pre></td></tr></table></figure>



<h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A. 多线程程序在一个核的cpu上运行，就是并发。</span><br><span class="line">B. 多线程程序在多个核的cpu上运行，就是并行。 </span><br></pre></td></tr></table></figure>



<h4 id="协程和线程"><a href="#协程和线程" class="headerlink" title="协程和线程"></a>协程和线程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。</span><br><span class="line">线程：一个线程上可以跑多个协程，协程是轻量级的线程。</span><br></pre></td></tr></table></figure>

<p><strong>goroutine 是由官方实现的超级 “线程池”。</strong></p>
<p><strong>goroutine 奉行通过通信来共享内存，而不是共享内存来通信</strong></p>
<p>每个实例 <code>4~5KB</code> 的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是go高并发的根本原因。</p>
<p>并发主要由切换时间片来实现”同时”运行，并行则是直接利用多核实现多线程的运行，go可以设置使用核数，以发挥多核计算机的能力。</p>
<h4 id="GPM机制"><a href="#GPM机制" class="headerlink" title="GPM机制"></a>GPM机制</h4><p><strong>GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统</strong>。 区别于操作系统调度OS线程。</p>
<ul>
<li>1.G很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li>
<li>2.P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li>
<li>3.M（machine）是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li>
</ul>
<p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p>
<p>P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p>
<p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p>
<h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h4><p>goroutine的概念类似于线程，但 goroutine是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p>
<p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。</p>
<p><strong>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。</strong></p>
<p>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;helloworld&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> test()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main func.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="线程开销"><a href="#线程开销" class="headerlink" title="线程开销"></a>线程开销</h5><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。</p>
<h4 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h4><p>Runtime使用Go语言运行所需要的基础设施：</p>
<ol>
<li>协程调度，内存分配，GC；</li>
<li>操作系统及CPU相关的操作封装（信号处理，系统调用，寄存器操作，原子操作等），CGO；</li>
<li>pprof，trace，race检测的支持；</li>
<li>map，channel，string等内置类型及反射的实现；</li>
</ol>
<p>go 的 runtime 代码在 go sdk 的 runtime 目录下,主要有所述的 4 块功能.</p>
<p>提到 runtime, 大家可能会想起 java, python 的 runtime. 不过 go 和这两者不太一样, java, python 的 runtime 是虚拟机, 而 go 的 runtime 和用户代码一起编译到一个可执行文件中.</p>
<p>用户代码和 runtime 代码除了代码组织上有界限外, 运行的时候并没有明显的界限. 如上所示, 一些常用的关键字被编译成 runtime 包下的一些函数调用.</p>
<h5 id="常用的几种方法"><a href="#常用的几种方法" class="headerlink" title="常用的几种方法"></a>常用的几种方法</h5><p>Go的运行时包runtime中包含了一些可以设置go运行时的环境的函数，比如运行最大有多少逻辑处理器（P），最多可以创建多少OS线程（M）等。</p>
<p><strong>runtime.Gosched()</strong></p>
<p>类似Java中线程的yeild方法， 当一个goroutine执行方法时候意味着当前goroutine放弃当前cpu的使用权，然后运行时会调度系统会调度其他goroutine占用cpu进行运行，放弃CPU使用权的goroutine并没有被阻塞，而是处于就绪状态，可以在随时获取到CPU情况下继续运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> runc() &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            runtime.Gosched()</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">11</span>; i &lt; <span class="number">20</span>; i++ &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">            runtime.Gosched()</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在单个逻辑处理p下，该p中本地队列里面的所有goroutine并不是顺序执行的，而是交叉并发执行的。</strong></p>
<p><strong>runtime.Goexit()</strong></p>
<p>退出当前线程</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;A.defer&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;B.defer&quot;</span>)</span><br><span class="line">            <span class="comment">// 结束协程</span></span><br><span class="line">            runtime.Goexit()</span><br><span class="line">            <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;C.defer&quot;</span>)</span><br><span class="line">            fmt.Println(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">        fmt.Println(<span class="string">&quot;A&quot;</span>)	<span class="comment">// 没有加载, 并没有输出</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.defer</span><br><span class="line">A.defer</span><br></pre></td></tr></table></figure>



<p><strong>runtime.GOMAXPROCS(n int)</strong></p>
<p>设置逻辑处理器个数,也就是设置GPM中的P的个数，默认P的个数是逻辑cpu的个数，比如在4核双线程的机器上P默认个数是8，调用该函数会返回设置前P的个数。</p>
<p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;A:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;B:&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> a()</span><br><span class="line">    <span class="keyword">go</span> b()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p><strong>单纯的将函数并发执行是没有意义的。 函数与函数间需要交换数据才能体现并发执行函数的意义。</strong></p>
<p>Go语言的并发模型是CSP (Communicating Sequential Processes)， <strong>提倡通过通信共享内存而不是通过共享内存而实现通信。</strong></p>
<p>goroutine 是Go程序并发的执行体， channel就是它们之间的链接。 channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p>
<p>Go语言中的通道 (channel) 是一种特殊的类型。 <strong>通道像一个传送带或者队列， 总是遵循先入先出 (First In First Out) 的规则， 保证收发数据的顺序。</strong> 每一个通道都是一个具体类型的导管， 也就是声明channel的时候需要为其指定元素类型。</p>
<h5 id="channel-类型"><a href="#channel-类型" class="headerlink" title="channel 类型"></a><strong>channel 类型</strong></h5><p>channel 是一种类型，一种引用类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br></pre></td></tr></table></figure>



<p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test1 <span class="keyword">chan</span> <span class="keyword">int</span>	<span class="comment">// 声明一个传递整型的值</span></span><br><span class="line"><span class="keyword">var</span> test2 <span class="keyword">chan</span> <span class="keyword">bool</span> <span class="comment">// 声明一个传递布尔型的值</span></span><br><span class="line"><span class="keyword">var</span> test3 <span class="keyword">chan</span> []<span class="keyword">int</span> <span class="comment">// 声明一个传递数组型的值</span></span><br></pre></td></tr></table></figure>



<h5 id="创建-channel"><a href="#创建-channel" class="headerlink" title="创建 channel"></a>创建 channel</h5><p>通道是引用类型，通道类型的空值是nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">fmt.Println(ch) <span class="comment">// &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>



<p>声明的通道后需要使用make函数初始化之后才能使用。</p>
<p>创建channel的格式如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure>

<p>列子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">test5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">test6 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>



<h5 id="channel-操作"><a href="#channel-操作" class="headerlink" title="channel 操作"></a>channel 操作</h5><p>通道有发送(send)、 接收(receive) 和关闭 (close) 三种操作</p>
<p>发送和接收都使用 <code>&lt;-</code> 符号</p>
<p>定义通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>将一个值发送到通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span>   <span class="comment">// 将10发送ch字符中</span></span><br></pre></td></tr></table></figure>

<p>从一个通道接收值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收并赋值给变量x</span></span><br><span class="line">&lt;-ch	   <span class="comment">// 从ch中接收并忽略结果</span></span><br></pre></td></tr></table></figure>

<p>通过内置的close函数关闭通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>注意：只有在接收放goroutine所有的数据发送完毕的时候才能关闭通道。 通道是可以被垃圾回收机制回收，它和关闭文件是不一样的， 在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p>
<p>关闭通道注意点：</p>
<ol>
<li>对一个关闭的通道再发送值就会导致panic</li>
<li>对一个关闭的通道进行接收会一直获取值直到通道为空</li>
<li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值</li>
<li>关闭一个已经关闭的通道会导致panic</li>
</ol>
<p><strong>无缓存通道</strong></p>
<p>无缓冲的通道又称为阻塞的通道</p>
<p>启用一个goroutine去接收值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ret := &lt;- c</span><br><span class="line">    fmt.Println(<span class="string">&quot;接收成功&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> recv(ch)	<span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">    ch &lt;- <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;发送成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。</p>
<p><strong>使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道。</strong></p>
<p><strong>有缓冲通道</strong></p>
<p>可以使用make函数初始化通道时候为其指定通道容量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道    ch &lt;- 10    fmt.Println(&quot;发送成功&quot;)&#125;</span></span><br></pre></td></tr></table></figure>

<p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p>
<p>我们可以使用内置的len函数获取通道内元素的数量，使用cap函数获取通道的容量，虽然我们很少会这么做。</p>
<p><strong>优雅从通道循环取值</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">// 开启goroutine将0-100的数发送到ch1中    go func() &#123;        for i := 0; i &lt; 100; i++ &#123;            ch1 &lt;- i        &#125;        close(ch1)    &#125;    // 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中    go func() &#123;        for &#123;            i, ok := &lt;-ch1	// 通道关闭后再取值 ok = false            if !ok &#123;                break            &#125;            ch2 &lt;- i * i        &#125;        close(ch2)    &#125;    // 主goroutine中从ch2中接收值打印    for i := range ch2 &#123;	// 通道关闭后会退出for range循环        fmt.Println(i)    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>例子中我们看到有两种方式在接收值的时候判断通道是否被关闭，我们通常使用的是for range的方式。</p>
<p><strong>单向通道</strong></p>
<p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 ch1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        out &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ch2 接收, ch1 发送</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- i * i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(ch1)</span><br><span class="line">    <span class="keyword">go</span> squarer(ch2, ch1)</span><br><span class="line">    printer(ch2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>&lt;-chan int</code> <strong>只能接收值</strong></p>
<p><code>chan&lt;- int</code> <strong>只能发送值</strong></p>
<p>在函数传参及任何赋值操作中将双向通道转换为单向通道是可以的，但反过来是不可以的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"># Go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/19/docker/docker%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A802/" rel="prev" title="docker技术之基础使用(二)">
      <i class="fa fa-chevron-left"></i> docker技术之基础使用(二)
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/22/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%8601/" rel="next" title="Python学习笔记之基础知识(一)">
      Python学习笔记之基础知识(一) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D"><span class="nav-number">1.1.</span> <span class="nav-text">命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.</span> <span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%90%8D%E7%A7%B0"><span class="nav-number">1.3.</span> <span class="nav-text">预定义的名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">1.4.</span> <span class="nav-text">变量声明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%A3%B0%E6%98%8E"><span class="nav-number">1.4.1.</span> <span class="nav-text">基础声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">1.4.2.</span> <span class="nav-text">简短变量声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">1.4.3.</span> <span class="nav-text">批量声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">1.4.4.</span> <span class="nav-text">指针变量声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#new%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-number">1.4.5.</span> <span class="nav-text">new函数变量声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="nav-number">1.4.6.</span> <span class="nav-text">变量的声明周期</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC"><span class="nav-number">1.5.</span> <span class="nav-text">赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E8%B5%8B%E5%80%BC"><span class="nav-number">1.5.1.</span> <span class="nav-text">元组赋值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E8%B5%8B%E5%80%BC%E6%80%A7"><span class="nav-number">1.5.2.</span> <span class="nav-text">可赋值性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.6.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.</span> <span class="nav-text">值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.8.</span> <span class="nav-text">引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E5%92%8C%E6%96%87%E4%BB%B6"><span class="nav-number">1.9.</span> <span class="nav-text">包和文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%8C%85"><span class="nav-number">1.9.1.</span> <span class="nav-text">导入包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8C%85"><span class="nav-number">1.9.2.</span> <span class="nav-text">初始化包</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#init-%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.3.</span> <span class="nav-text">init 函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.10.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B"><span class="nav-number">1.11.</span> <span class="nav-text">整型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#int"><span class="nav-number">1.11.1.</span> <span class="nav-text">int</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int8"><span class="nav-number">1.11.2.</span> <span class="nav-text">int8</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int16"><span class="nav-number">1.11.3.</span> <span class="nav-text">int16</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int32"><span class="nav-number">1.11.4.</span> <span class="nav-text">int32</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int64"><span class="nav-number">1.11.5.</span> <span class="nav-text">int64</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#int-int8-int16-int32-int64-%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="nav-number">1.11.6.</span> <span class="nav-text">int int8 int16 int32 int64 取值范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#uintptr"><span class="nav-number">1.11.7.</span> <span class="nav-text">uintptr</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-number">1.12.</span> <span class="nav-text">浮点数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#float32"><span class="nav-number">1.12.1.</span> <span class="nav-text">float32</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#float64"><span class="nav-number">1.12.2.</span> <span class="nav-text">float64</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E6%95%B0"><span class="nav-number">1.13.</span> <span class="nav-text">复数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B"><span class="nav-number">1.14.</span> <span class="nav-text">布尔型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.15.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.15.1.</span> <span class="nav-text">格式化字符串</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.16.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.17.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1"><span class="nav-number">1.18.</span> <span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#slice"><span class="nav-number">1.18.1.</span> <span class="nav-text">slice</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map"><span class="nav-number">1.18.2.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#channel"><span class="nav-number">1.18.3.</span> <span class="nav-text">channel</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">1.19.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%9C%B0%E5%9D%80%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.19.1.</span> <span class="nav-text">指针地址和指针类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.20.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.21.</span> <span class="nav-text">反射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">函数特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">2.2.</span> <span class="nav-text">函数声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">2.3.1.</span> <span class="nav-text">值传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="nav-number">2.3.2.</span> <span class="nav-text">引用传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">2.3.3.</span> <span class="nav-text">函数参数传递</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E5%80%BC"><span class="nav-number">2.4.</span> <span class="nav-text">不定参数传值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">任意类型的不定参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.6.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">2.8.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">2.9.</span> <span class="nav-text">递归函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8-defer"><span class="nav-number">2.10.</span> <span class="nav-text">延迟调用 (defer)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#defer%E7%89%B9%E6%80%A7"><span class="nav-number">2.10.1.</span> <span class="nav-text">defer特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#defer%E7%94%A8%E9%80%94"><span class="nav-number">2.10.2.</span> <span class="nav-text">defer用途</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#defer-%E4%B8%8E-return"><span class="nav-number">2.10.3.</span> <span class="nav-text">defer 与 return</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">2.11.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#panic"><span class="nav-number">2.11.1.</span> <span class="nav-text">panic</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#recover"><span class="nav-number">2.11.2.</span> <span class="nav-text">recover</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">2.12.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="nav-number">2.12.1.</span> <span class="nav-text">方法定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="nav-number">2.12.2.</span> <span class="nav-text">匿名方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.12.3.</span> <span class="nav-text">表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#error-%E6%A1%88%E4%BE%8B"><span class="nav-number">2.12.4.</span> <span class="nav-text">error 案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="nav-number">3.1.</span> <span class="nav-text">匿名字段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#go%E6%94%AF%E6%8C%81%E5%8F%AA%E6%8F%90%E4%BE%9B%E7%B1%BB%E5%9E%8B%E8%80%8C%E4%B8%8D%E5%86%99%E5%AD%97%E6%AE%B5%E5%90%8D%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B9%9F%E7%A7%B0%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%AD%97%E6%AE%B5"><span class="nav-number">3.1.1.</span> <span class="nav-text">go支持只提供类型而不写字段名的方式，也就是匿名字段，也称为嵌入字段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E5%90%8D%E5%AD%97%E6%AE%B5%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">3.1.2.</span> <span class="nav-text">同名字段的情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E9%83%BD%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5%E5%8E%BB%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.3.</span> <span class="nav-text">所有的内置类型和自定义类型都是可以作为匿名字段去使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="nav-number">3.1.4.</span> <span class="nav-text">指针类型匿名字段</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.2.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.1.</span> <span class="nav-text">接口类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.2.2.</span> <span class="nav-text">接口的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.3.</span> <span class="nav-text">值接收者和指针接收者实现接口的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.2.4.</span> <span class="nav-text">类型与接口的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%B5%8C%E5%A5%97"><span class="nav-number">3.2.5.</span> <span class="nav-text">接口嵌套</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.2.6.</span> <span class="nav-text">空接口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">4.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87"><span class="nav-number">4.1.</span> <span class="nav-text">知识储备</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Go-runtime-%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.1.1.</span> <span class="nav-text">Go runtime 介绍</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">4.3.</span> <span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.4.</span> <span class="nav-text">协程和线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GPM%E6%9C%BA%E5%88%B6"><span class="nav-number">4.5.</span> <span class="nav-text">GPM机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#goroutine"><span class="nav-number">4.6.</span> <span class="nav-text">goroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">4.6.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%BC%80%E9%94%80"><span class="nav-number">4.6.2.</span> <span class="nav-text">线程开销</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#runtime"><span class="nav-number">4.7.</span> <span class="nav-text">runtime</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">4.7.1.</span> <span class="nav-text">常用的几种方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel"><span class="nav-number">4.8.</span> <span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#channel-%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.8.1.</span> <span class="nav-text">channel 类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-channel"><span class="nav-number">4.8.2.</span> <span class="nav-text">创建 channel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#channel-%E6%93%8D%E4%BD%9C"><span class="nav-number">4.8.3.</span> <span class="nav-text">channel 操作</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ChangHao</p>
  <div class="site-description" itemprop="description">技术分享</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hltfaith" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hltfaith" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChangHao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  

    </div>
</body>
</html>
